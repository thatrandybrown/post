import {uuid} from 'uuidv4';
import {createClient} from 'redis';
import util from 'util';
const {promisify} = util;

export default ({config, messageHandler}) => {
    const client = createClient(config.cache.url);

    const hgetall = promisify(client.hgetall).bind(client);
    const hset = promisify(client.hset).bind(client);
    const hget = promisify(client.hget).bind(client);

    /**
     * the message recipient will just push back a message
     * the service will process it and push it to redis
     *
     * perhaps the service should also do a health check on redis
     * and send a message if redis fails / reboots to rehydrate
     *
     * or should it re-hydrate on service launch
    */
    messageHandler.read(config.messaging.rcvQueue, msg => {
        const message = JSON.parse(msg.content.toString())
        hset(config.cache.hash, message.id, JSON.stringify(message));
    });

    return [{
        resource: "/",
        behaviors: [
            {endpoint: "/", method: "get", behavior: [
                async (req, res, next) => {
                    const data = await hgetall(config.cache.hash) || {};
                    return res.send(
                        Object.keys(data).reduce(
                            (acc, item) => [...acc, JSON.parse(data[item])],
                            []
                        )
                    )
                }
            ]},
            {endpoint: "/:postId", method: "get", behavior: [
                async (req, res, next) => {
                    const post = await hget(config.cache.hash, req.params.postId);
                    if(!post) return next({status: 404});
                    return res.send(JSON.parse(post));
                }
            ]},
            {endpoint: "/", method: "post", behavior: [
                (req, res, next) => {
                    /**
                     * probably good to do some data checking on the body
                     * before sending it on
                    **/

                    /**
                     * in this case, if req.body has an id, it will overwrite
                     * the generated id.
                     *
                     * If a tree or graph structure needs to be implied by the
                     * versions, then it will need to be somewhere other than
                     * id, which will always be what is provided by the request
                    **/
                    const authHeader = req.get("Authorization")

                    if(!authHeader) return next({status: 401, message: "No authorization header"});
                    const authToken = authHeader.split(" ");
                    if(authToken[0] !== "Bearer")
                      return next({status: 401, message: "Bearer token not present"});
                    const apiKey = authToken[1];

                    if(apiKey !== config.write_key) return next({status: 403});

                    /**
                     * In the event a UID is sent, it is removed as this has to be generated by the server to
                     * ensure uniqueness. However, another option might be to preserve the full request and send it
                     * as a subdocument on the message.
                     *
                     * The reason it is currently not sent as a subdocument is that the rest of the infra currently
                     * expects a flat document.
                     *
                     * This allows both the document ID and the timestamp for creation to be overwritten by the client.
                     * There are a lot of problems with this approach, especially that the service cannot capture when it
                     * received the request so the amount of deference is not documented.
                     *
                     * I'll probably regret this.
                     */
                    let {id, ...request} = req.body;

                    /**
                     * if a request.id is sent that is null or 0, a new id will be generated,
                     * but it will still be overwritten by the request if it is not extracted.
                     */
                    id = id || uuid();
                    const timestamp = Date.now();
                    const uid = uuid();

                    messageHandler.write(
                        config.messaging.sendQueue,
                        JSON.stringify({
                            ...request,
                            id,
                            timestamp,
                            uid
                        })
                    );
                    return res.status(202).send({id, uid, timestamp})
                }
            ]}
        ]
    }];
}